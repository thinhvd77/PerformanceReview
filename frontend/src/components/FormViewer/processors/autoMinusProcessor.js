// autoMinusProcessor.js
// Processor for AUTO_MINUS_RULES - Section IV (Điểm trừ)

import { normalizeText, formatPercentVi } from "../utils/formUtils.js";
import { findRowIndexByCriteria } from "../utils/rowUtils.js";
import { mergeAddresses, numToCol } from "../utils/tableUtils.js";
import { buildParentFormula } from "../utils/formulaUtils.js";

/**
 * Process AUTO_MINUS_RULES for Section IV (Điểm trừ - minus points)
 *
 * @param {Object} params - Processing parameters
 * @param {Object} params.table - Current table state
 * @param {Array} params.rules - AUTO_MINUS_RULES array
 * @param {Set} params.ruleKeySet - AUTO_MINUS_RULE_KEY_SET
 * @param {number} params.scoreColIdx - Score column index
 * @param {number} params.planColIdx - Plan column index
 * @param {number} params.actualColIdx - Actual column index
 * @param {number} params.prevActualColIdx - Previous quarter actual column index
 * @param {number} params.prevPlanColIdx - Previous quarter plan column index (not used but kept for consistency)
 * @param {number} params.noteColIdx - Note column index
 * @param {Object} params.childrenScoreAddrs - Children score addresses by parent row index
 * @param {Object} params.cellInputs - Current cell inputs
 * @param {Object} params.computedByAddr - Computed values by address
 * @param {number} params.virtualRowNo - Current virtual row number for generating new addresses
 * @param {Function} params.resolveCellNumericValue - Function to resolve cell numeric value
 * @returns {Object|null} State updates or null if no changes
 */
export function processMinusRules({
    table,
    rules,
    ruleKeySet,
    scoreColIdx,
    planColIdx,
    actualColIdx,
    prevActualColIdx,
    prevPlanColIdx,
    noteColIdx,
    childrenScoreAddrs,
    cellInputs,
    computedByAddr,
    virtualRowNo,
    resolveCellNumericValue,
}) {
    // Validation
    if (
        !table?.rows ||
        scoreColIdx == null ||
        planColIdx == null ||
        actualColIdx == null
    ) {
        return null;
    }

    const rows = table.rows;

    // Find parent row by label (not STT) to support different form numbering schemes
    const parentRowIdx = findRowIndexByCriteria(rows, "Điểm trừ (tối đa 10 điểm)", 1, true);
    if (parentRowIdx === -1) return null;

    // Build auto-row tracking maps
    const autoRowsByKey = new Map();
    const autoAddrsSet = new Set();
    rows.forEach((row, idx) => {
        const key = row?.autoGeneratedKey;
        if (key && ruleKeySet.has(key)) {
            autoRowsByKey.set(key, { row, idx });
            const addr = row?.cells?.[scoreColIdx]?.addr;
            if (addr) autoAddrsSet.add(addr);
        }
    });

    // Filter manual addresses (exclude auto-generated)
    const currentManualAddrs = childrenScoreAddrs[parentRowIdx] || [];
    const manualAddrs = currentManualAddrs.filter(
        (addr) => addr && !autoAddrsSet.has(addr)
    );

    // If manual addresses changed, update and return
    if (manualAddrs.length !== currentManualAddrs.length) {
        return {
            childrenScoreAddrs: {
                ...childrenScoreAddrs,
                [parentRowIdx]: manualAddrs,
            },
        };
    }

    // Helper: Get addresses of other auto-generated rows (excluding given key)
    const otherAutoAddrsFor = (excludeKey) =>
        Array.from(autoRowsByKey.entries())
            .filter(([key]) => key !== excludeKey)
            .map(([, info]) => info.row?.cells?.[scoreColIdx]?.addr)
            .filter(Boolean);

    // Get parent row criteria
    const parentRow = rows[parentRowIdx];
    const parentCriteria = String(parentRow?.cells?.[1]?.value || "").trim();

    // Helper: Build parent formula with merged addresses
    const parentFormulaFor = (autoAddrs) => {
        const allAddrs = mergeAddresses(manualAddrs, autoAddrs);
        return buildParentFormula(parentCriteria, allAddrs);
    };

    // Helper: Find insertion index (count existing child rows after parent)
    // Child rows have empty STT column (column 0)
    // Stop when we encounter a row with STT value (next parent/section)
    const findInsertIndex = (rowsList, parentIdx) => {
        let insertIdx = parentIdx + 1;

        // Count existing child rows (rows with empty STT column)
        while (insertIdx < rowsList.length) {
            const row = rowsList[insertIdx];
            const stt = String(row?.cells?.[0]?.value || "").trim();

            // Stop when we encounter a row with STT value (indicates a parent row)
            if (stt) {
                break;
            }

            insertIdx++;
        }

        return insertIdx;
    };

    // Process a single minus rule
    const processMinusRule = (rule) => {
        const { growthLabel, bonusLabel, key, fixedPoints, step, maxPoints } =
            rule;
        const autoInfo = autoRowsByKey.get(key) || null;
        const autoRowIdx = autoInfo?.idx ?? -1;
        const autoAddr = autoInfo?.row?.cells?.[scoreColIdx]?.addr || null;
        const otherAutoAddrs = otherAutoAddrsFor(key);

        // Find growth row by criteria
        const growthRowIdx = findRowIndexByCriteria(rows, growthLabel, 1, true);

        let planValue = null;
        let actualValue = null;
        let prevActualValue = null;

        if (growthRowIdx !== -1) {
            const planCell = rows[growthRowIdx]?.cells?.[planColIdx];
            const actualCell = rows[growthRowIdx]?.cells?.[actualColIdx];
            const prevActualCell =
                prevActualColIdx != null
                    ? rows[growthRowIdx]?.cells?.[prevActualColIdx]
                    : null;

            // Check if parent has input
            const hasParentInput = actualCell?.input || actualCell?.addr;
            const parentActualValue = resolveCellNumericValue(actualCell);
            const parentPlanValue = resolveCellNumericValue(planCell);
            const parentPrevActualValue = prevActualCell
                ? resolveCellNumericValue(prevActualCell)
                : null;

            if (
                hasParentInput &&
                parentActualValue !== null &&
                parentActualValue !== 0
            ) {
                // Case 1: Parent has input - use parent values
                planValue = parentPlanValue;
                actualValue = parentActualValue;
                prevActualValue = parentPrevActualValue;
            } else {
                // Case 2&3: Sum from child rows
                let totalPlan = 0;
                let totalActual = 0;
                let totalPrevActual = 0;
                let hasChildData = false;

                // Find child rows (rows with empty STT column)
                for (let i = growthRowIdx + 1; i < rows.length; i++) {
                    const childRow = rows[i];
                    const childSTT = String(
                        childRow?.cells?.[0]?.value || ""
                    ).trim();

                    // Stop when encountering next parent row (row with STT value)
                    if (childSTT) break;

                    const childPlanCell = childRow?.cells?.[planColIdx];
                    const childActualCell = childRow?.cells?.[actualColIdx];
                    const childPrevActualCell =
                        prevActualColIdx != null
                            ? childRow?.cells?.[prevActualColIdx]
                            : null;

                    if (childPlanCell || childActualCell) {
                        const childPlan =
                            resolveCellNumericValue(childPlanCell) || 0;
                        const childActual =
                            resolveCellNumericValue(childActualCell) || 0;
                        const childPrevActual = childPrevActualCell
                            ? resolveCellNumericValue(childPrevActualCell) || 0
                            : 0;

                        totalPlan += childPlan;
                        totalActual += childActual;
                        totalPrevActual += childPrevActual;

                        if (childActual > 0) hasChildData = true;
                    }
                }

                if (hasChildData || totalPlan > 0) {
                    planValue = totalPlan > 0 ? totalPlan : parentPlanValue;
                    actualValue = totalActual;
                    prevActualValue =
                        totalPrevActual > 0
                            ? totalPrevActual
                            : parentPrevActualValue;
                } else {
                    // Fallback to parent values
                    planValue = parentPlanValue;
                    actualValue = parentActualValue;
                    prevActualValue = parentPrevActualValue;
                }
            }
        }

        // Helper: Remove auto-generated row
        const removeAutoRow = () => {
            if (!autoInfo) return false;
            const desiredFormula = parentFormulaFor(otherAutoAddrs);
            const nextRows = rows.filter(
                (row) => row?.autoGeneratedKey !== key
            );
            // Find parent row by label (not STT)
            const parentIdxNext = findRowIndexByCriteria(nextRows, "Điểm trừ (tối đa 10 điểm)", 1, true);
            if (parentIdxNext !== -1) {
                const parentRow = nextRows[parentIdxNext];
                if (parentRow?.cells) {
                    const parentCells = parentRow.cells.map((cell, idx) =>
                        idx === scoreColIdx
                            ? { ...cell, formula: desiredFormula }
                            : cell
                    );
                    nextRows[parentIdxNext] = {
                        ...parentRow,
                        cells: parentCells,
                    };
                }
            }

            // Prepare updates
            const updates = {
                table: { ...table, rows: nextRows },
            };

            // Remove cell input if exists
            if (autoAddr && cellInputs?.[autoAddr] !== undefined) {
                const { [autoAddr]: _omit, ...restInputs } = cellInputs;
                updates.cellInputs = restInputs;
            }

            return updates;
        };

        // Calculate minus points based on rule type
        let minusPoints = 0;
        let noteText = "";

        // Handle fixed-point rules (Nợ nhóm 2, Nợ xấu)
        if (fixedPoints && !step) {
            // Compare current vs previous quarter
            const valid =
                actualValue !== null &&
                planValue !== null &&
                Number.isFinite(actualValue) &&
                Number.isFinite(planValue) &&
                planValue !== 0;

            if (valid) {
                const increased = actualValue > planValue;
                if (increased) {
                    minusPoints = Math.abs(fixedPoints); // Use absolute value
                    const increaseRatio =
                        (actualValue - planValue) /
                        Math.abs(planValue);
                    noteText = `Tăng ${formatPercentVi(increaseRatio)}`;
                }
            }
        }
        // Handle step-based rules (Nguồn vốn giảm, Dư nợ giảm)
        else if (step && maxPoints) {
            // Compare current quarter actual vs previous quarter actual
            const valid =
                prevActualValue !== null &&
                actualValue !== null &&
                Number.isFinite(prevActualValue) &&
                prevActualValue !== 0 &&
                Number.isFinite(actualValue);

            if (valid) {
                const negativeRatio =
                    prevActualValue > actualValue
                        ? (prevActualValue - actualValue) /
                        Math.abs(prevActualValue)
                        : 0;

                if (negativeRatio > 0) {
                    const absStep = Math.abs(step);
                    const rawPoints = Math.floor((negativeRatio + 1e-9) / absStep);
                    const absMaxPoints = Math.abs(maxPoints);
                    minusPoints = Math.min(absMaxPoints, rawPoints);
                    noteText = `Giảm ${formatPercentVi(
                        negativeRatio
                    )} so với Quý trước`;
                }
            }
        }

        // If no minus points, remove the auto-generated row
        if (minusPoints <= 0) {
            return removeAutoRow();
        }

        // If auto-generated row doesn't exist, create it
        if (!autoInfo) {
            const scoreColLetter = numToCol(scoreColIdx + 1);
            const newAddr = `${scoreColLetter}${virtualRowNo}`;
            const desiredFormula = parentFormulaFor(
                mergeAddresses(otherAutoAddrs, newAddr)
            );

            const nextRows = [...rows];
            // Find parent row by label (not STT)
            const parentIdxNext = findRowIndexByCriteria(nextRows, "Điểm trừ (tối đa 10 điểm)", 1, true);
            if (parentIdxNext === -1) return null;

            const columnCount =
                nextRows[parentIdxNext]?.cells?.length ||
                table?.columns?.length ||
                0;
            if (!columnCount) return null;

            const insertIdx = findInsertIndex(nextRows, parentIdxNext);

            // Create new row cells
            const newCells = Array.from({ length: columnCount }, (_, cIdx) => ({
                addr: null,
                value: "",
                rowSpan: 1,
                colSpan: 1,
                hidden: false,
                input: false,
            }));

            // Set bonus label in criteria column
            if (newCells[1]) newCells[1] = { ...newCells[1], value: bonusLabel };

            // Set note text
            if (noteColIdx != null && newCells[noteColIdx]) {
                newCells[noteColIdx] = {
                    ...newCells[noteColIdx],
                    value: noteText,
                };
            }

            // Set score cell
            newCells[scoreColIdx] = {
                ...newCells[scoreColIdx],
                addr: newAddr,
                value: minusPoints,
                input: false,
            };

            // Insert new row
            nextRows.splice(insertIdx, 0, {
                autoGenerated: true,
                autoGeneratedKey: key,
                cells: newCells,
            });

            // Update parent formula
            const parentRow = nextRows[parentIdxNext];
            if (parentRow?.cells) {
                const parentCells = parentRow.cells.map((cell, idx) =>
                    idx === scoreColIdx
                        ? { ...cell, formula: desiredFormula }
                        : cell
                );
                nextRows[parentIdxNext] = {
                    ...parentRow,
                    cells: parentCells,
                };
            }

            return {
                table: { ...table, rows: nextRows },
                virtualRowNo: virtualRowNo + 1,
            };
        }

        // If auto-generated row exists, check if it needs updating
        const combinedAutoAddrs = mergeAddresses(
            otherAutoAddrs,
            autoAddr ? [autoAddr] : []
        );
        const desiredFormula = parentFormulaFor(combinedAutoAddrs);
        const currentFormula =
            rows[parentRowIdx]?.cells?.[scoreColIdx]?.formula || "";
        const currentScore = autoInfo.row?.cells?.[scoreColIdx]?.value;
        const currentNote =
            noteColIdx != null
                ? autoInfo.row?.cells?.[noteColIdx]?.value || ""
                : "";

        const needRowUpdate =
            String(currentScore ?? "") !== String(minusPoints) ||
            currentNote !== noteText;
        const needParentUpdate = currentFormula !== desiredFormula;

        if (!needRowUpdate && !needParentUpdate) return null;

        // Update existing auto-generated row
        const nextRows = rows.map((row, idx) => {
            if (idx === autoRowIdx && row?.cells) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        return { ...cell, value: minusPoints };
                    }
                    if (noteColIdx != null && cIdx === noteColIdx) {
                        return { ...cell, value: noteText };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            // Find parent row by label (not STT) to support different form numbering schemes
            if (normalizeText(row?.cells?.[1]?.value) === normalizeText("Điểm trừ (tối đa 10 điểm)") && row?.cells) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        return { ...cell, formula: desiredFormula };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            return row;
        });

        return { table: { ...table, rows: nextRows } };
    };

    // Process all rules sequentially, return first update
    for (const rule of rules) {
        const result = processMinusRule(rule);
        if (result) return result;
    }

    return null;
}
