// autoBonusProcessor.js
// Processor for AUTO_BONUS_RULES - Section V (Điểm thưởng)

import { normalizeText } from "../utils/formUtils.js";
import { findRowIndexByCriteria } from "../utils/rowUtils.js";
import { mergeAddresses, numToCol } from "../utils/tableUtils.js";
import { buildParentFormula } from "../utils/formulaUtils.js";

/**
 * Process AUTO_BONUS_RULES for Section V (Điểm thưởng - bonus points)
 * This is an async function as it fetches data from backend
 *
 * @param {Object} params - Processing parameters
 * @param {Object} params.table - Current table state
 * @param {Array} params.rules - AUTO_BONUS_RULES array
 * @param {Set} params.ruleKeySet - AUTO_BONUS_RULE_KEY_SET
 * @param {number} params.scoreColIdx - Score column index
 * @param {number} params.actualColIdx - Actual column index
 * @param {number} params.noteColIdx - Note column index
 * @param {Object} params.childrenScoreAddrs - Children score addresses by parent row index
 * @param {Object} params.cellInputs - Current cell inputs
 * @param {Object} params.computedByAddr - Computed values by address
 * @param {number} params.virtualRowNo - Current virtual row number for generating new addresses
 * @param {number} params.selectedQuarter - Selected quarter (1-4)
 * @param {number} params.selectedYear - Selected year
 * @param {Object} params.api - API instance for fetching data
 * @param {Function} params.resolveCellNumericValue - Function to resolve cell numeric value
 * @param {string} params.currentUsername - Current user's username
 * @returns {Promise<Object|null>} State updates or null if no changes
 */
export async function processBonusRules({
    table,
    rules,
    ruleKeySet,
    scoreColIdx,
    actualColIdx,
    noteColIdx,
    childrenScoreAddrs,
    cellInputs,
    computedByAddr,
    virtualRowNo,
    selectedQuarter,
    selectedYear,
    api,
    resolveCellNumericValue,
    currentUsername,
}) {
    // Validation
    if (!table?.rows || scoreColIdx == null || actualColIdx == null) {
        return null;
    }

    const rows = table.rows;

    // Fetch annual plan data from database
    let annualPlanData = {};

    if (currentUsername && selectedYear) {
        try {
            const { data } = await api.get('/annual-plans', {
                params: { username: currentUsername, year: selectedYear }
            });
            if (data?.data) {
                annualPlanData = data.data;
            }
        } catch (err) {
            // Continue without annual plan data
        }
    }

    // Map growth labels to metric keys for annual plan lookup
    const labelToMetricKey = {
        "Tăng trưởng nguồn vốn": "capital_growth",
        "Tăng trưởng dư nợ": "loan_growth",
        "Thu dịch vụ": "service_revenue",
        "Thu hồi nợ đã XLRR": "debt_recovery",
        "Tài chính": "finance",
    };

    // Fetch already awarded bonuses for this user in this year
    const awardedBonusMap = new Map();
    if (currentUsername && selectedYear) {
        try {
            const { data } = await api.get('/bonus-awards', {
                params: { username: currentUsername, year: selectedYear }
            });
            if (data?.data && Array.isArray(data.data)) {
                data.data.forEach(award => {
                    awardedBonusMap.set(award.key, award.quarter);
                });
            }
        } catch (err) {
            // Continue without checking - better to award duplicate than miss valid bonus
        }
    }

    // Find parent row (Section V - "Điểm thưởng (tối đa 05 điểm)")
    const parentRowIdx = findRowIndexByCriteria(
        rows,
        "Điểm thưởng (tối đa 05 điểm)",
        1,
        true
    );
    if (parentRowIdx === -1) return null;

    // Build auto-row tracking maps
    const autoRowsByKey = new Map();
    const autoAddrsSet = new Set();
    rows.forEach((row, idx) => {
        const key = row?.autoGeneratedKey;
        if (key && ruleKeySet.has(key)) {
            autoRowsByKey.set(key, { row, idx });
            const addr = row?.cells?.[scoreColIdx]?.addr;
            if (addr) autoAddrsSet.add(addr);
        }
    });

    // Filter manual addresses (exclude auto-generated)
    const currentManualAddrs = childrenScoreAddrs[parentRowIdx] || [];
    const manualAddrs = currentManualAddrs.filter(
        (addr) => addr && !autoAddrsSet.has(addr)
    );

    // If manual addresses changed, update and return
    if (manualAddrs.length !== currentManualAddrs.length) {
        return {
            childrenScoreAddrs: {
                ...childrenScoreAddrs,
                [parentRowIdx]: manualAddrs,
            },
        };
    }

    // Helper: Get addresses of other auto-generated rows (excluding given key)
    const otherAutoAddrsFor = (excludeKey) =>
        Array.from(autoRowsByKey.entries())
            .filter(([key]) => key !== excludeKey)
            .map(([, info]) => info.row?.cells?.[scoreColIdx]?.addr)
            .filter(Boolean);

    // Get parent row criteria
    const parentRow = rows[parentRowIdx];
    const parentCriteria = String(parentRow?.cells?.[1]?.value || "").trim();

    // Helper: Build parent formula with merged addresses
    const parentFormulaFor = (autoAddrs) => {
        const allAddrs = mergeAddresses(manualAddrs, autoAddrs);
        return buildParentFormula(parentCriteria, allAddrs);
    };

    // Helper: Find insertion index (count existing child rows after parent)
    // Child rows have empty STT column (column 0)
    // Stop when we encounter a row with STT value (next parent/section)
    const findInsertIndex = (rowsList, parentIdx) => {
        let insertIdx = parentIdx + 1;

        // Count existing child rows (rows with empty STT column)
        while (insertIdx < rowsList.length) {
            const row = rowsList[insertIdx];
            const stt = String(row?.cells?.[0]?.value || "").trim();

            // Stop when we encounter a row with STT value (indicates a parent row)
            if (stt) {
                break;
            }

            insertIdx++;
        }

        return insertIdx;
    };

    // Process a single bonus rule (async)
    const processBonusRule = async (rule) => {
        const { growthLabel, bonusLabel, key, fixedPoints } = rule;
        const autoInfo = autoRowsByKey.get(key) || null;
        const autoRowIdx = autoInfo?.idx ?? -1;
        const autoAddr = autoInfo?.row?.cells?.[scoreColIdx]?.addr || null;
        const otherAutoAddrs = otherAutoAddrsFor(key);

        // Check if this bonus was already awarded in a previous quarter of this year
        const previouslyAwardedQuarter = awardedBonusMap.get(key);
        const wasAlreadyAwarded = previouslyAwardedQuarter !== undefined;

        // Support multiple growth labels (array)
        const labels = Array.isArray(growthLabel) ? growthLabel : [growthLabel];

        let annualPlanValue = null;
        let currentQuarterActual = 0;

        // Process each label to find matching row and compare current quarter actual with annual plan
        for (const label of labels) {
            const growthRowIdx = rows.findIndex(
                (row) =>
                    normalizeText(row?.cells?.[1]?.value) ===
                    normalizeText(label)
            );

            if (growthRowIdx === -1) continue;

            // Get annual plan from database using label-to-metric mapping
            const normalizedLabel = normalizeText(label);
            const metricKey = Object.entries(labelToMetricKey).find(
                ([key]) => normalizeText(key) === normalizedLabel
            )?.[1];

            // Use annual plan from database
            let labelAnnualPlan = null;
            if (metricKey && annualPlanData[metricKey] !== undefined) {
                const rawValue = annualPlanData[metricKey];
                // Parse to number to ensure proper comparison
                const parsed = parseFloat(rawValue);
                labelAnnualPlan = Number.isFinite(parsed) ? parsed : null;
            }

            // Get current quarter's actual from the form
            const actualCell = rows[growthRowIdx]?.cells?.[actualColIdx];
            const labelCurrentActual = resolveCellNumericValue(actualCell);

            // Check if THIS label's current quarter actual meets annual plan
            if (labelAnnualPlan !== null &&
                Number.isFinite(labelAnnualPlan) &&
                labelAnnualPlan !== 0 &&
                labelCurrentActual !== null &&
                Number.isFinite(labelCurrentActual) &&
                labelCurrentActual >= labelAnnualPlan) {
                // This label meets annual plan, use its values
                annualPlanValue = labelAnnualPlan;
                currentQuarterActual = labelCurrentActual;
                break; // Stop checking other labels, we found a winner
            }
        }

        // Validate data
        const valid =
            annualPlanValue !== null &&
            currentQuarterActual !== null &&
            Number.isFinite(annualPlanValue) &&
            annualPlanValue !== 0 &&
            Number.isFinite(currentQuarterActual);

        // Helper: Remove auto-generated row
        const removeAutoRow = () => {
            if (!autoInfo) return false;
            const desiredFormula = parentFormulaFor(otherAutoAddrs);
            const nextRows = rows.filter(
                (row) => row?.autoGeneratedKey !== key
            );
            const parentIdxNext = findRowIndexByCriteria(
                nextRows,
                "Điểm thưởng (tối đa 05 điểm)",
                1,
                true
            );
            if (parentIdxNext !== -1) {
                const parentRow = nextRows[parentIdxNext];
                if (parentRow?.cells) {
                    const parentCells = parentRow.cells.map((cell, idx) =>
                        idx === scoreColIdx
                            ? { ...cell, formula: desiredFormula }
                            : cell
                    );
                    nextRows[parentIdxNext] = {
                        ...parentRow,
                        cells: parentCells,
                    };
                }
            }

            // Prepare updates
            const updates = {
                table: { ...table, rows: nextRows },
            };

            // Remove cell input if exists
            if (autoAddr && cellInputs?.[autoAddr] !== undefined) {
                const { [autoAddr]: _omit, ...restInputs } = cellInputs;
                updates.cellInputs = restInputs;
            }

            return updates;
        };

        // Determine bonus points and note text
        let bonusPoints = 0;
        let noteText = "";

        // Check if criteria is met
        const criteriaMet = valid && currentQuarterActual >= annualPlanValue;

        if (criteriaMet) {
            if (wasAlreadyAwarded) {
                // Criteria met but already awarded in previous quarter
                bonusPoints = 0;
                noteText = `Đã được cộng điểm tại Quý ${previouslyAwardedQuarter}`;
            } else {
                // Criteria met and not yet awarded - award full points
                bonusPoints = fixedPoints;
                noteText = "Hoàn thành KH năm";
            }
        }

        // If criteria not met and row doesn't exist, don't create it
        if (!criteriaMet && !autoInfo) {
            return null;
        }

        // If criteria not met and row exists, remove it
        if (!criteriaMet && autoInfo) {
            return removeAutoRow();
        }

        // If auto-generated row doesn't exist, create it (criteria must be met to reach here)
        if (!autoInfo) {
            const scoreColLetter = numToCol(scoreColIdx + 1);
            const newAddr = `${scoreColLetter}${virtualRowNo}`;

            // Build formula based on whether points are awarded
            let desiredFormula;
            if (bonusPoints > 0) {
                // Include this address in parent formula (contributes to total)
                desiredFormula = parentFormulaFor(
                    mergeAddresses(otherAutoAddrs, newAddr)
                );
            } else {
                // Don't include this address in parent formula (0 points, already awarded)
                desiredFormula = parentFormulaFor(otherAutoAddrs);
            }

            const nextRows = [...rows];
            const parentIdxNext = findRowIndexByCriteria(
                nextRows,
                "Điểm thưởng (tối đa 05 điểm)",
                1,
                true
            );
            if (parentIdxNext === -1) return null;

            const columnCount =
                nextRows[parentIdxNext]?.cells?.length ||
                table?.columns?.length ||
                0;
            if (!columnCount) return null;

            const insertIdx = findInsertIndex(nextRows, parentIdxNext);

            // Create new row cells
            const newCells = Array.from({ length: columnCount }, (_, cIdx) => ({
                addr: null,
                value: "",
                rowSpan: 1,
                colSpan: 1,
                hidden: false,
                input: false,
            }));

            // Set bonus label in criteria column
            if (newCells[1]) newCells[1] = { ...newCells[1], value: bonusLabel };

            // Set note text
            if (noteColIdx != null && newCells[noteColIdx]) {
                newCells[noteColIdx] = {
                    ...newCells[noteColIdx],
                    value: noteText,
                };
            }

            // Set score cell (with or without address based on whether points awarded)
            if (bonusPoints > 0) {
                // Has points - include address so it's counted in formula
                newCells[scoreColIdx] = {
                    ...newCells[scoreColIdx],
                    addr: newAddr,
                    value: bonusPoints,
                    input: false,
                };
            } else {
                // No points (already awarded) - no address so it's not counted in formula
                newCells[scoreColIdx] = {
                    ...newCells[scoreColIdx],
                    value: 0,
                    input: false,
                };
            }

            // Insert new row
            nextRows.splice(insertIdx, 0, {
                autoGenerated: true,
                autoGeneratedKey: key,
                cells: newCells,
            });

            // Update parent formula
            const parentRow = nextRows[parentIdxNext];
            if (parentRow?.cells) {
                const parentCells = parentRow.cells.map((cell, idx) =>
                    idx === scoreColIdx
                        ? { ...cell, formula: desiredFormula }
                        : cell
                );
                nextRows[parentIdxNext] = {
                    ...parentRow,
                    cells: parentCells,
                };
            }

            return {
                table: { ...table, rows: nextRows },
                virtualRowNo: bonusPoints > 0 ? virtualRowNo + 1 : virtualRowNo, // Only increment if address was used
            };
        }

        // If auto-generated row exists, check if it needs updating
        const currentHasAddr = autoAddr !== null;
        const shouldHaveAddr = bonusPoints > 0;

        // Build desired formula based on whether this row should contribute points
        const combinedAutoAddrs = shouldHaveAddr
            ? mergeAddresses(otherAutoAddrs, autoAddr ? [autoAddr] : [])
            : otherAutoAddrs;
        const desiredFormula = parentFormulaFor(combinedAutoAddrs);

        const currentFormula =
            rows[parentRowIdx]?.cells?.[scoreColIdx]?.formula || "";
        const currentScore = autoInfo.row?.cells?.[scoreColIdx]?.value;
        const currentNote =
            noteColIdx != null
                ? autoInfo.row?.cells?.[noteColIdx]?.value || ""
                : "";

        const needRowUpdate =
            String(currentScore ?? "") !== String(bonusPoints) ||
            currentNote !== noteText ||
            currentHasAddr !== shouldHaveAddr; // Address state changed
        const needParentUpdate = currentFormula !== desiredFormula;

        if (!needRowUpdate && !needParentUpdate) return null;

        // Update existing auto-generated row
        const nextRows = rows.map((row, idx) => {
            if (idx === autoRowIdx && row?.cells) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        // Update score value and address based on whether points are awarded
                        if (shouldHaveAddr) {
                            return { ...cell, value: bonusPoints, addr: autoAddr };
                        } else {
                            return { ...cell, value: 0, addr: null };
                        }
                    }
                    if (noteColIdx != null && cIdx === noteColIdx) {
                        return { ...cell, value: noteText };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            // Find parent row by label (not STT) to support different form numbering schemes
            if (normalizeText(row?.cells?.[1]?.value) === normalizeText("Điểm thưởng (tối đa 05 điểm)") && row?.cells) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        return { ...cell, formula: desiredFormula };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            return row;
        });

        return { table: { ...table, rows: nextRows } };
    };

    // Process all rules sequentially (async), return first update
    for (const rule of rules) {
        const result = await processBonusRule(rule);
        if (result) return result;
    }

    return null;
}
