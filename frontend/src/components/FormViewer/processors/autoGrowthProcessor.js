// autoGrowthProcessor.js
// Handles Section III (Điểm cộng) auto-generation logic

import { normalizeText, formatPercentVi } from "../utils/formUtils.js";
import {
    findRowIndexByCriteria,
    findRowIndexBySTTNormalized,
} from "../utils/rowUtils.js";
import { mergeAddresses, numToCol } from "../utils/tableUtils.js";
import { buildParentFormula } from "../utils/formulaUtils.js";

/**
 * Process AUTO_GROWTH_RULES to auto-generate bonus rows for Section III
 * @param {Object} params - Processing parameters
 * @param {Object} params.table - Current table state
 * @param {Array} params.rules - AUTO_GROWTH_RULES array
 * @param {Set} params.ruleKeySet - Set of valid rule keys
 * @param {number} params.scoreColIdx - Score column index
 * @param {number} params.planColIdx - Plan column index
 * @param {number} params.actualColIdx - Actual column index
 * @param {number} params.noteColIdx - Note column index
 * @param {Object} params.childrenScoreAddrs - Manual child addresses by parent row index
 * @param {Object} params.cellInputs - Current cell inputs
 * @param {Object} params.computedByAddr - Computed values by address
 * @param {number} params.virtualRowNo - Current virtual row number
 * @param {Function} params.resolveCellNumericValue - Function to resolve cell numeric value
 * @returns {Object|null} State updates {table, cellInputs, virtualRowNo, childrenScoreAddrs} or null if no changes
 */
export function processGrowthRules({
    table,
    rules,
    ruleKeySet,
    scoreColIdx,
    planColIdx,
    actualColIdx,
    noteColIdx,
    childrenScoreAddrs,
    cellInputs,
    computedByAddr,
    virtualRowNo,
    resolveCellNumericValue,
}) {
    if (
        !table?.rows ||
        scoreColIdx == null ||
        planColIdx == null ||
        actualColIdx == null
    )
        return null;

    const rows = table.rows;
    const parentRowIdx = findRowIndexBySTTNormalized(rows, "iii");
    if (parentRowIdx === -1) return null;

    // Build map of auto-generated rows by key
    const autoRowsByKey = new Map();
    const autoAddrsSet = new Set();
    rows.forEach((row, idx) => {
        const key = row?.autoGeneratedKey;
        if (key && ruleKeySet.has(key)) {
            autoRowsByKey.set(key, { row, idx });
            const addr = row?.cells?.[scoreColIdx]?.addr;
            if (addr) autoAddrsSet.add(addr);
        }
    });

    // Filter manual addresses (exclude auto-generated)
    const currentManualAddrs = childrenScoreAddrs[parentRowIdx] || [];
    const manualAddrs = currentManualAddrs.filter(
        (addr) => addr && !autoAddrsSet.has(addr)
    );

    // If manual addresses changed, return update to clean them up
    if (manualAddrs.length !== currentManualAddrs.length) {
        return {
            childrenScoreAddrs: {
                ...childrenScoreAddrs,
                [parentRowIdx]: manualAddrs,
            },
        };
    }

    // Helper: Get addresses of other auto-generated rows (excluding one key)
    const otherAutoAddrsFor = (excludeKey) =>
        Array.from(autoRowsByKey.entries())
            .filter(([key]) => key !== excludeKey)
            .map(([, info]) => info.row?.cells?.[scoreColIdx]?.addr)
            .filter(Boolean);

    // Get parent criteria for formula building
    const parentRow = rows[parentRowIdx];
    const parentCriteria = String(parentRow?.cells?.[1]?.value || "").trim();

    // Helper: Build parent formula with given auto addresses
    const parentFormulaFor = (autoAddrs) => {
        const allAddrs = mergeAddresses(manualAddrs, autoAddrs);
        return buildParentFormula(parentCriteria, allAddrs);
    };

    // Helper: Find insertion index after parent row and existing children
    // Child rows have empty STT column (column 0)
    // Stop when we encounter a row with STT value (next parent/section)
    const findInsertIndex = (rowsList, parentIdx) => {
        let insertIdx = parentIdx + 1;

        // Count existing child rows (rows with empty STT column)
        while (insertIdx < rowsList.length) {
            const row = rowsList[insertIdx];
            const stt = String(row?.cells?.[0]?.value || "").trim();

            // Stop when we encounter a row with STT value (indicates a parent row)
            if (stt) {
                break;
            }

            insertIdx++;
        }

        return insertIdx;
    };

    // Process a single rule
    const processRule = (rule) => {
        const { growthLabel, bonusLabel, key } = rule;
        const autoInfo = autoRowsByKey.get(key) || null;
        const autoRowIdx = autoInfo?.idx ?? -1;
        const autoAddr = autoInfo?.row?.cells?.[scoreColIdx]?.addr || null;
        const otherAutoAddrs = otherAutoAddrsFor(key);

        // Find the growth row this rule references
        const growthRowIdx = findRowIndexByCriteria(
            rows,
            growthLabel,
            1,
            true
        );

        let planValue = null;
        let actualValue = null;

        if (growthRowIdx !== -1) {
            const planCell = rows[growthRowIdx]?.cells?.[planColIdx];
            const actualCell = rows[growthRowIdx]?.cells?.[actualColIdx];

            // Check if parent row has input
            const hasParentInput = actualCell?.input || actualCell?.addr;
            const parentActualValue = resolveCellNumericValue(actualCell);
            const parentPlanValue = resolveCellNumericValue(planCell);

            if (
                hasParentInput &&
                parentActualValue !== null &&
                parentActualValue !== 0
            ) {
                // Type 1: Direct parent input
                planValue = parentPlanValue;
                actualValue = parentActualValue;
            } else {
                // Type 2&3: Aggregate from child rows
                let totalPlan = 0;
                let totalActual = 0;
                let hasChildData = false;

                // Find child rows (rows with empty STT column)
                for (let i = growthRowIdx + 1; i < rows.length; i++) {
                    const childRow = rows[i];
                    const childSTT = String(
                        childRow?.cells?.[0]?.value || ""
                    ).trim();

                    // Stop when encountering another parent row (row with STT value)
                    if (childSTT) break;

                    const childPlanCell = childRow?.cells?.[planColIdx];
                    const childActualCell = childRow?.cells?.[actualColIdx];

                    if (childPlanCell || childActualCell) {
                        const childPlan =
                            resolveCellNumericValue(childPlanCell) || 0;
                        const childActual =
                            resolveCellNumericValue(childActualCell) || 0;

                        totalPlan += childPlan;
                        totalActual += childActual;

                        if (childActual > 0) hasChildData = true;
                    }
                }

                if (hasChildData || totalPlan > 0) {
                    planValue = totalPlan > 0 ? totalPlan : parentPlanValue;
                    actualValue = totalActual;
                } else {
                    // Fallback to parent values
                    planValue = parentPlanValue;
                    actualValue = parentActualValue;
                }
            }
        }

        // Validate we have usable data
        const valid =
            planValue !== null &&
            actualValue !== null &&
            Number.isFinite(planValue) &&
            planValue !== 0 &&
            Number.isFinite(actualValue);

        // Calculate positive growth ratio
        const positiveRatio = valid
            ? Math.max(0, (actualValue - planValue) / Math.abs(planValue))
            : 0;

        // Calculate bonus points based on rule configuration
        let bonusPoints = 0;
        if (rule.threshold && rule.fixedPoints) {
            // Fixed points if threshold met (e.g., Thu hồi nợ đã XLRR)
            const actualRatio = valid ? actualValue / planValue : 0;
            bonusPoints = actualRatio >= rule.threshold ? rule.fixedPoints : 0;
        } else {
            // Step-based calculation for percentage growth
            const step =
                typeof rule.step === "number" && rule.step > 0
                    ? rule.step
                    : 0.05;
            const rawPoints =
                positiveRatio > 0
                    ? Math.floor((positiveRatio + 1e-9) / step)
                    : 0;
            bonusPoints = Math.min(5, rawPoints);
        }

        // Build note text
        const noteText = (() => {
            if (rule.threshold && rule.fixedPoints) {
                const actualRatio = valid ? actualValue / planValue : 0;
                return actualRatio >= rule.threshold
                    ? `Đạt ${formatPercentVi(actualRatio)} (≥110%)`
                    : "";
            } else {
                return positiveRatio > 0
                    ? `Vượt ${formatPercentVi(positiveRatio)}`
                    : "";
            }
        })();

        // Helper: Remove auto-generated row
        const removeAutoRow = () => {
            if (!autoInfo) return null;

            const desiredFormula = parentFormulaFor(otherAutoAddrs);
            const nextRows = rows.filter((row) => row?.autoGeneratedKey !== key);
            const parentIdxNext = findRowIndexBySTTNormalized(nextRows, "iii");

            if (parentIdxNext !== -1) {
                const parentRow = nextRows[parentIdxNext];
                if (parentRow?.cells) {
                    const parentCells = parentRow.cells.map((cell, idx) =>
                        idx === scoreColIdx
                            ? { ...cell, formula: desiredFormula }
                            : cell
                    );
                    nextRows[parentIdxNext] = {
                        ...parentRow,
                        cells: parentCells,
                    };
                }
            }

            // Clean up cell input if exists
            const updatedCellInputs = { ...cellInputs };
            if (autoAddr && autoAddr in updatedCellInputs) {
                delete updatedCellInputs[autoAddr];
            }

            return {
                table: { ...table, rows: nextRows },
                cellInputs: updatedCellInputs,
            };
        };

        // If no bonus points, remove the row
        if (bonusPoints <= 0) {
            return removeAutoRow();
        }

        // If row doesn't exist yet, create it
        if (!autoInfo) {
            if (!valid) return null;

            const scoreColLetter = numToCol(scoreColIdx + 1);
            const newAddr = `${scoreColLetter}${virtualRowNo}`;
            const desiredFormula = parentFormulaFor(
                mergeAddresses(otherAutoAddrs, newAddr)
            );

            const nextRows = [...rows];
            const parentIdxNext = findRowIndexBySTTNormalized(nextRows, "iii");
            if (parentIdxNext === -1) return null;

            const columnCount =
                nextRows[parentIdxNext]?.cells?.length ||
                table?.columns?.length ||
                0;
            if (!columnCount) return null;

            const insertIdx = findInsertIndex(nextRows, parentIdxNext);

            // Create new row cells
            const newCells = Array.from({ length: columnCount }, (_, cIdx) => ({
                addr: null,
                value: "",
                rowSpan: 1,
                colSpan: 1,
                hidden: false,
                input: false,
            }));

            // Set criteria label
            if (newCells[1]) newCells[1] = { ...newCells[1], value: bonusLabel };

            // Set note text
            if (noteColIdx != null && newCells[noteColIdx]) {
                newCells[noteColIdx] = {
                    ...newCells[noteColIdx],
                    value: noteText,
                };
            }

            // Set score value
            newCells[scoreColIdx] = {
                ...newCells[scoreColIdx],
                addr: newAddr,
                value: bonusPoints,
                input: false,
            };

            // Insert new row
            nextRows.splice(insertIdx, 0, {
                autoGenerated: true,
                autoGeneratedKey: key,
                cells: newCells,
            });

            // Update parent formula
            const parentRow = nextRows[parentIdxNext];
            if (parentRow?.cells) {
                const parentCells = parentRow.cells.map((cell, idx) =>
                    idx === scoreColIdx
                        ? { ...cell, formula: desiredFormula }
                        : cell
                );
                nextRows[parentIdxNext] = {
                    ...parentRow,
                    cells: parentCells,
                };
            }

            return {
                table: { ...table, rows: nextRows },
                virtualRowNo: virtualRowNo + 1,
            };
        }

        // Row exists, check if it needs updating
        if (!valid) {
            return removeAutoRow();
        }

        const combinedAutoAddrs = mergeAddresses(
            otherAutoAddrs,
            autoAddr ? [autoAddr] : []
        );
        const desiredFormula = parentFormulaFor(combinedAutoAddrs);
        const currentFormula =
            rows[parentRowIdx]?.cells?.[scoreColIdx]?.formula || "";
        const currentScore = autoInfo.row?.cells?.[scoreColIdx]?.value;
        const currentNote =
            noteColIdx != null
                ? autoInfo.row?.cells?.[noteColIdx]?.value || ""
                : "";

        const needRowUpdate =
            String(currentScore ?? "") !== String(bonusPoints) ||
            currentNote !== noteText;
        const needParentUpdate = currentFormula !== desiredFormula;

        if (!needRowUpdate && !needParentUpdate) return null;

        // Update existing row
        const nextRows = rows.map((row, idx) => {
            if (idx === autoRowIdx && row?.cells) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        return { ...cell, value: bonusPoints };
                    }
                    if (noteColIdx != null && cIdx === noteColIdx) {
                        return { ...cell, value: noteText };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            if (
                normalizeText(row?.cells?.[0]?.value) === "iii" &&
                row?.cells
            ) {
                const cells = row.cells.map((cell, cIdx) => {
                    if (cIdx === scoreColIdx) {
                        return { ...cell, formula: desiredFormula };
                    }
                    return cell;
                });
                return { ...row, cells };
            }
            return row;
        });

        return {
            table: { ...table, rows: nextRows },
        };
    };

    // Process all rules in order, return first update
    for (const rule of rules) {
        const result = processRule(rule);
        if (result) return result;
    }

    return null;
}
