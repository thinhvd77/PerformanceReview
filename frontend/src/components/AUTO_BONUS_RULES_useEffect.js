// AUTO_BONUS_RULES useEffect for Section V (Điểm thưởng) - Year-end bonus based on cumulative quarterly achievement
// This code should be inserted after AUTO_MINUS_RULES useEffect in FormViewer.jsx

useEffect(() => {
    if (!table?.rows || scoreColIdx == null || annualPlanColIdx == null || actualColIdx == null)
        return;

    const rows = table.rows;
    const findParentIndex = (rowsList) =>
        rowsList.findIndex(
            (row) => normalizeText(row?.cells?.[0]?.value) === "v"
        );

    const parentRowIdx = findParentIndex(rows);
    if (parentRowIdx === -1) return;

    const autoRowsByKey = new Map();
    const autoAddrsSet = new Set();
    rows.forEach((row, idx) => {
        const key = row?.autoGeneratedKey;
        if (key && AUTO_BONUS_RULE_KEY_SET.has(key)) {
            autoRowsByKey.set(key, { row, idx });
            const addr = row?.cells?.[scoreColIdx]?.addr;
            if (addr) autoAddrsSet.add(addr);
        }
    });

    const currentManualAddrs = childrenScoreAddrs[parentRowIdx] || [];
    const manualAddrs = currentManualAddrs.filter(
        (addr) => addr && !autoAddrsSet.has(addr)
    );
    if (manualAddrs.length !== currentManualAddrs.length) {
        setChildrenScoreAddrs((prev) => ({
            ...prev,
            [parentRowIdx]: manualAddrs,
        }));
        return;
    }

    const otherAutoAddrsFor = (excludeKey) =>
        Array.from(autoRowsByKey.entries())
            .filter(([key]) => key !== excludeKey)
            .map(([, info]) => info.row?.cells?.[scoreColIdx]?.addr)
            .filter(Boolean);

    const parentRow = rows[parentRowIdx];
    const parentCriteria = String(
        parentRow?.cells?.[1]?.value || ""
    ).trim();

    const parentFormulaFor = (autoAddrs) => {
        const allAddrs = mergeAddresses(manualAddrs, autoAddrs);
        return buildParentFormula(parentCriteria, allAddrs);
    };

    const findInsertIndex = (rowsList, parentIdx) => {
        let insertIdx = parentIdx + 1;
        while (insertIdx < rowsList.length) {
            const roman = String(
                rowsList[insertIdx]?.cells?.[0]?.value || ""
            ).trim();
            if (/^(II|III|IV|V|D)$/i.test(roman)) break;
            insertIdx += 1;
        }
        return insertIdx;
    };

    // Helper: Fetch cumulative actuals from Q1 to current quarter
    const fetchCumulativeActuals = async () => {
        try {
            const cumulativeData = {};
            // Fetch all quarters from Q1 to current quarter
            for (let q = 1; q <= selectedQuarter; q++) {
                const { data } = await api.get("/quarterly-metrics", {
                    params: {
                        quarter: q,
                        year: selectedYear,
                    },
                });

                if (data?.metrics) {
                    // Accumulate metrics
                    Object.entries(data.metrics).forEach(([type, value]) => {
                        if (!cumulativeData[type]) cumulativeData[type] = 0;
                        cumulativeData[type] += parseFloat(value) || 0;
                    });
                }
            }
            return cumulativeData;
        } catch (err) {
            console.warn("Failed to fetch cumulative metrics:", err?.response?.data || err.message);
            return {};
        }
    };

    // Helper: Find growth row by label (support array labels)
    const findGrowthRowByLabels = (growthLabel) => {
        const labels = Array.isArray(growthLabel) ? growthLabel : [growthLabel];

        for (const label of labels) {
            const idx = rows.findIndex(
                (row) =>
                    normalizeText(row?.cells?.[1]?.value) ===
                    normalizeText(label)
            );
            if (idx !== -1) return idx;
        }
        return -1;
    };

    const processBonusRule = async (rule) => {
        const {
            growthLabel,
            bonusLabel,
            key,
            fixedPoints,
        } = rule;
        const autoInfo = autoRowsByKey.get(key) || null;
        const autoRowIdx = autoInfo?.idx ?? -1;
        const autoAddr = autoInfo?.row?.cells?.[scoreColIdx]?.addr || null;
        const otherAutoAddrs = otherAutoAddrsFor(key);

        // Find growth row (support array labels)
        const growthRowIdx = findGrowthRowByLabels(growthLabel);

        let annualPlanValue = null;
        let cumulativeActual = 0;

        if (growthRowIdx !== -1) {
            // Get annual plan from "Kế hoạch năm" column
            const annualPlanCell = rows[growthRowIdx]?.cells?.[annualPlanColIdx];
            annualPlanValue = resolveCellNumericValue(annualPlanCell);

            // Fetch cumulative actual from backend
            const cumulativeData = await fetchCumulativeActuals();

            // Map growth label to metric type
            const labels = Array.isArray(growthLabel) ? growthLabel : [growthLabel];
            for (const label of labels) {
                const normalized = normalizeText(label);
                let metricType = null;

                if (normalized.includes("tang truong nguon von")) {
                    metricType = "capital_growth";
                } else if (normalized.includes("tang truong du no")) {
                    metricType = "loan_growth";
                } else if (normalized.includes("thu dich vu")) {
                    metricType = "service_revenue";
                } else if (normalized.includes("thu hoi no da xlrr")) {
                    metricType = "debt_recovery";
                } else if (normalized.includes("tai chinh")) {
                    metricType = "finance";
                }

                if (metricType && cumulativeData[metricType] != null) {
                    cumulativeActual += cumulativeData[metricType];
                }
            }
        }

        const valid =
            annualPlanValue !== null &&
            cumulativeActual !== null &&
            Number.isFinite(annualPlanValue) &&
            annualPlanValue !== 0 &&
            Number.isFinite(cumulativeActual);

        const removeAutoRow = () => {
            if (!autoInfo) return false;
            const desiredFormula = parentFormulaFor(otherAutoAddrs);
            setTable((prev) => {
                if (!prev?.rows) return prev;
                const nextRows = prev.rows.filter(
                    (row) => row?.autoGeneratedKey !== key
                );
                const parentIdxNext = findParentIndex(nextRows);
                if (parentIdxNext !== -1) {
                    const parentRow = nextRows[parentIdxNext];
                    if (parentRow?.cells) {
                        const parentCells = parentRow.cells.map(
                            (cell, idx) =>
                                idx === scoreColIdx
                                    ? { ...cell, formula: desiredFormula }
                                    : cell
                        );
                        nextRows[parentIdxNext] = {
                            ...parentRow,
                            cells: parentCells,
                        };
                    }
                }
                return { ...prev, rows: nextRows };
            });
            if (autoAddr) {
                setCellInputs((prev) => {
                    if (!prev || !(autoAddr in prev)) return prev;
                    const { [autoAddr]: _omit, ...rest } = prev;
                    return rest;
                });
            }
            return true;
        };

        // Calculate bonus points: award fixedPoints if cumulative >= annual plan
        const bonusPoints = valid && cumulativeActual >= annualPlanValue ? fixedPoints : 0;
        const noteText = valid && cumulativeActual >= annualPlanValue ? "Hoàn thành KH năm" : "";

        if (bonusPoints <= 0) {
            return removeAutoRow();
        }

        if (!autoInfo) {
            const scoreColLetter = numToCol(scoreColIdx + 1);
            const newAddr = `${scoreColLetter}${virtualRowNo}`;
            const desiredFormula = parentFormulaFor(
                mergeAddresses(otherAutoAddrs, newAddr)
            );
            setTable((prev) => {
                if (!prev?.rows) return prev;
                const nextRows = [...prev.rows];
                const parentIdxNext = findParentIndex(nextRows);
                if (parentIdxNext === -1) return prev;
                const columnCount =
                    nextRows[parentIdxNext]?.cells?.length ||
                    prev.columns?.length ||
                    table?.columns?.length ||
                    0;
                if (!columnCount) return prev;
                const insertIdx = findInsertIndex(nextRows, parentIdxNext);
                const newCells = Array.from(
                    { length: columnCount },
                    (_, cIdx) => ({
                        addr: null,
                        value: "",
                        rowSpan: 1,
                        colSpan: 1,
                        hidden: false,
                        input: false,
                    })
                );
                if (newCells[1])
                    newCells[1] = { ...newCells[1], value: bonusLabel };
                if (noteColIdx != null && newCells[noteColIdx]) {
                    newCells[noteColIdx] = {
                        ...newCells[noteColIdx],
                        value: noteText,
                    };
                }
                newCells[scoreColIdx] = {
                    ...newCells[scoreColIdx],
                    addr: newAddr,
                    value: bonusPoints,
                    input: false,
                };
                nextRows.splice(insertIdx, 0, {
                    autoGenerated: true,
                    autoGeneratedKey: key,
                    cells: newCells,
                });
                const parentRow = nextRows[parentIdxNext];
                if (parentRow?.cells) {
                    const parentCells = parentRow.cells.map((cell, idx) =>
                        idx === scoreColIdx
                            ? { ...cell, formula: desiredFormula }
                            : cell
                    );
                    nextRows[parentIdxNext] = {
                        ...parentRow,
                        cells: parentCells,
                    };
                }
                return { ...prev, rows: nextRows };
            });
            setVirtualRowNo((n) => n + 1);
            return true;
        }

        const combinedAutoAddrs = mergeAddresses(
            otherAutoAddrs,
            autoAddr ? [autoAddr] : []
        );
        const desiredFormula = parentFormulaFor(combinedAutoAddrs);
        const currentFormula =
            rows[parentRowIdx]?.cells?.[scoreColIdx]?.formula || "";
        const currentScore = autoInfo.row?.cells?.[scoreColIdx]?.value;
        const currentNote =
            noteColIdx != null
                ? autoInfo.row?.cells?.[noteColIdx]?.value || ""
                : "";
        const needRowUpdate =
            String(currentScore ?? "") !== String(bonusPoints) ||
            currentNote !== noteText;
        const needParentUpdate = currentFormula !== desiredFormula;

        if (!needRowUpdate && !needParentUpdate) return false;

        setTable((prev) => {
            if (!prev?.rows) return prev;
            const nextRows = prev.rows.map((row, idx) => {
                if (idx === autoRowIdx && row?.cells) {
                    const cells = row.cells.map((cell, cIdx) => {
                        if (cIdx === scoreColIdx) {
                            return { ...cell, value: bonusPoints };
                        }
                        if (noteColIdx != null && cIdx === noteColIdx) {
                            return { ...cell, value: noteText };
                        }
                        return cell;
                    });
                    return { ...row, cells };
                }
                if (
                    normalizeText(row?.cells?.[0]?.value) === "v" &&
                    row?.cells
                ) {
                    const cells = row.cells.map((cell, cIdx) => {
                        if (cIdx === scoreColIdx) {
                            return { ...cell, formula: desiredFormula };
                        }
                        return cell;
                    });
                    return { ...row, cells };
                }
                return row;
            });
            return { ...prev, rows: nextRows };
        });
        return true;
    };

    // Process all bonus rules sequentially (async)
    (async () => {
        for (const rule of AUTO_BONUS_RULES) {
            if (await processBonusRule(rule)) return;
        }
    })();
}, [
    table,
    scoreColIdx,
    annualPlanColIdx,
    actualColIdx,
    noteColIdx,
    childrenScoreAddrs,
    cellInputs,
    computedByAddr,
    selectedQuarter,
    selectedYear,
    virtualRowNo,
]);
